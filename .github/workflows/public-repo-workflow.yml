# GitHub Actions workflow for PUBLIC repository
# Save this as .github/workflows/fetch-sofa-metrics.yml in your public repo

name: Fetch SOFA Metrics from Private Repo

on:
  schedule:
    - cron: '45 */6 * * *'  # 45 minutes after private repo collection
  workflow_dispatch:
    inputs:
      force_update:
        description: "Force update even if no changes detected"
        required: false
        default: "false"
        type: boolean
      output_path:
        description: "Path where metrics should be saved (e.g., data/resources/metrics.json)"
        required: false
        default: "data/resources/metrics.json"

permissions:
  contents: write

concurrency:
  group: fetch-sofa-metrics-${{ github.ref }}
  cancel-in-progress: false

jobs:
  fetch-metrics:
    runs-on: ubuntu-latest
    
    env:
      PRIVATE_REPO_TOKEN: ${{ secrets.PRIVATE_REPO_TOKEN }}
      OUTPUT_PATH: ${{ inputs.output_path || vars.METRICS_OUTPUT_PATH || 'data/resources/metrics.json' }}
    
    steps:
      - name: Checkout public repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch metrics from private repo
        run: |
          set -e  # Exit on any error
          
          echo "üîÑ Fetching metrics from headmin/sofa-metrics-collector..."
          
          # Verify token is set
          if [ -z "$PRIVATE_REPO_TOKEN" ]; then
            echo "‚ùå PRIVATE_REPO_TOKEN is not set"
            exit 1
          fi
          
          # Retry mechanism for transient failures
          MAX_ATTEMPTS=3
          ATTEMPT=1
          
          # Fetch file content via GitHub API
          HTTP_CODE=$(curl -w "%{http_code}" -o api_response.json \
               -H "Authorization: Bearer $PRIVATE_REPO_TOKEN" \
               -H "Accept: application/vnd.github.v3+json" \
               -H "User-Agent: SOFA-Metrics-Fetcher/1.0" \
               -s \
               https://api.github.com/repos/headmin/sofa-metrics-collector/contents/data/metrics/latest.json)
          
          echo "üì° HTTP Response Code: $HTTP_CODE"
          
          # Check HTTP status
          if [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå HTTP Error $HTTP_CODE"
            echo "API Response:"
            cat api_response.json
            exit 1
          fi
          
          # Verify we got valid JSON with content field
          if ! jq -e '.content' api_response.json >/dev/null 2>&1; then
            echo "‚ùå Invalid API response - missing content field"
            echo "API Response:"
            cat api_response.json
            exit 1
          fi
          
          # Decode base64 content and save to output path
          echo "üìÅ Creating directory: $(dirname "$OUTPUT_PATH")"
          mkdir -p "$(dirname "$OUTPUT_PATH")"
          
          echo "üîì Decoding base64 content..."
          jq -r '.content' api_response.json | base64 -d > temp_metrics.json
          
          # Verify decoded JSON is valid
          if ! jq empty temp_metrics.json 2>/dev/null; then
            echo "‚ùå Decoded content is not valid JSON"
            echo "First 500 chars of decoded content:"
            head -c 500 temp_metrics.json
            exit 1
          fi
          
          # Transform for public (remove internal fields, add source)
          echo "üîÑ Transforming metrics for public consumption..."
          jq '. + {"source": "sofa-metrics-collector"} | del(.notes?)' temp_metrics.json > "$OUTPUT_PATH"
          
          # Display summary
          echo "‚úÖ Successfully fetched and saved metrics to: $OUTPUT_PATH"
          echo "üìä Metrics Summary:"
          echo "   Total Requests: $(jq -r '.metrics.totalRequests.formatted' "$OUTPUT_PATH")"
          echo "   Page Views: $(jq -r '.metrics.pageViews.formatted' "$OUTPUT_PATH")"
          echo "   Bandwidth: $(jq -r '.metrics.bandwidth.formatted' "$OUTPUT_PATH")"
          echo "   Cache Ratio: $(jq -r '.metrics.cacheRatio.formatted' "$OUTPUT_PATH")"
          echo "   Timestamp: $(jq -r '.timestamp' "$OUTPUT_PATH")"
          
          # Cleanup temp files
          rm -f api_response.json temp_metrics.json
          
          echo "üéâ Metrics fetch completed successfully!"

      - name: Check for changes
        id: changes
        run: |
          # Check if metrics file has changed or is new
          echo "üîç Checking for changes in $OUTPUT_PATH..."
          
          # Show file info
          if [ -f "$OUTPUT_PATH" ]; then
            echo "‚úÖ File exists: $OUTPUT_PATH ($(wc -c < "$OUTPUT_PATH") bytes)"
          else
            echo "‚ùå File missing: $OUTPUT_PATH"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check if file exists in git
          if git ls-files --error-unmatch "$OUTPUT_PATH" >/dev/null 2>&1; then
            echo "üìÅ File is tracked by git, checking for changes..."
            
            # Show current file timestamp for comparison
            CURRENT_TIMESTAMP=$(jq -r '.timestamp' "$OUTPUT_PATH" 2>/dev/null || echo "unknown")
            echo "üìä Current metrics timestamp: $CURRENT_TIMESTAMP"
            
            if git diff --quiet "$OUTPUT_PATH" 2>/dev/null; then
              echo "has_changes=false" >> $GITHUB_OUTPUT
              echo "üìä No changes detected - metrics are identical"
              echo "üí° Metrics may already be up-to-date"
            else
              echo "has_changes=true" >> $GITHUB_OUTPUT
              echo "üìä Changes detected in metrics file"
              echo "üìà Differences:"
              git diff --stat "$OUTPUT_PATH" || true
              git diff "$OUTPUT_PATH" | head -20 || true
            fi
          else
            echo "üìÅ File is new (not tracked by git)"
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "üìä New metrics file will be added"
          fi
          
          # Show the decision
          CHANGES_VALUE=$(grep "has_changes=" $GITHUB_OUTPUT | tail -1 | cut -d'=' -f2)
          echo "üéØ Final decision: has_changes=$CHANGES_VALUE"

      - name: Setup git
        if: steps.changes.outputs.has_changes == 'true' || inputs.force_update == 'true'
        run: |
          git config user.name "SOFA Metrics Bot"
          git config user.email "metrics-bot@macadmin.me"

      - name: Commit updated metrics
        if: steps.changes.outputs.has_changes == 'true' || inputs.force_update == 'true'
        run: |
          echo "üìù Preparing to commit changes..."
          
          # Show current git status
          echo "Git status before commit:"
          git status --porcelain || true
          
          # Extract key metrics for commit message
          TIMESTAMP=$(jq -r '.timestamp' "$OUTPUT_PATH")
          REQUESTS=$(jq -r '.metrics.totalRequests.formatted' "$OUTPUT_PATH")
          PAGEVIEWS=$(jq -r '.metrics.pageViews.formatted' "$OUTPUT_PATH")
          BANDWIDTH=$(jq -r '.metrics.bandwidth.formatted' "$OUTPUT_PATH")
          CACHE_RATIO=$(jq -r '.metrics.cacheRatio.formatted' "$OUTPUT_PATH")
          
          echo "üìÅ Adding file to git: $OUTPUT_PATH"
          git add "$OUTPUT_PATH"
          
          # Show what will be committed
          echo "Changes to be committed:"
          git diff --cached --stat || true
          
          # Create readable commit message
          READABLE_DATE=$(date -d "$TIMESTAMP" '+%Y-%m-%d %H:%M UTC' 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%S.%fZ" "$TIMESTAMP" '+%Y-%m-%d %H:%M UTC' 2>/dev/null || echo "$TIMESTAMP")
          
          echo "üí¨ Committing with message..."
          git commit -m "üìä Update SOFA metrics ($READABLE_DATE)

          - Requests: $REQUESTS
          - Page Views: $PAGEVIEWS
          - Bandwidth: $BANDWIDTH
          - Cache Ratio: $CACHE_RATIO
          
          Auto-updated from sofa-metrics-collector"
          
          echo "‚úÖ Commit successful"

      - name: Push changes
        if: steps.changes.outputs.has_changes == 'true' || inputs.force_update == 'true'
        run: |
          git push

      - name: Upload metrics artifact
        uses: actions/upload-artifact@v4
        with:
          name: sofa-metrics-${{ github.run_id }}
          path: ${{ env.OUTPUT_PATH }}
          retention-days: 30

  verify-metrics:
    runs-on: ubuntu-latest
    needs: fetch-metrics
    if: always()
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Verify metrics file
        env:
          OUTPUT_PATH: ${{ inputs.output_path || vars.METRICS_OUTPUT_PATH || 'data/resources/metrics.json' }}
        run: |
          if [ -f "$OUTPUT_PATH" ]; then
            echo "‚úÖ Metrics file exists at: $OUTPUT_PATH"
            echo "üìä File size: $(wc -c < "$OUTPUT_PATH") bytes"
            echo "üïí Timestamp: $(jq -r '.timestamp' "$OUTPUT_PATH" 2>/dev/null || echo 'Invalid JSON')"
            
            # Validate JSON structure
            if jq empty "$OUTPUT_PATH" 2>/dev/null; then
              echo "‚úÖ Valid JSON format"
            else
              echo "‚ùå Invalid JSON format"
            fi
          else
            echo "‚ùå Metrics file not found at: $OUTPUT_PATH"
          fi